bounds_and_transform_method = make_default_bounds_and_transform_methods(),
minimise_likelihood = FALSE
)
}
x <- pmap(.l = non_drought_combinations,
.f = numerical_optimiser_objects,
data = data,
start_stop = start_stop_indexes
)
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
View(non_drought_combinations)
non_drought_combinations[[1]]
non_drought_combinations[[1]][1]
x <- numerical_optimiser_objects(gauge = non_drought_combinations[[1]][1],
streamflow_model = non_drought_combinations[[2]][1],
objective_function = non_drought_combinations[[3]][1],
data = data,
start_stop = start_stop_indexes)
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
View(non_drought_combinations)
# remove a list level for the streamflow_model and objective_functions
non_drought_combinations <- unlist(non_drought_combinations$non_drought_streamflow_models, recursive = FALSE)
View(non_drought_combinations)
# remove a list level for the streamflow_model and objective_functions
non_drought_combinations <- unlist(non_drought_combinations, recursive = FALSE)
# I need to find all the combinations of all_gauges, non_drought_streamflow_models and all_objective_functions
non_drought_combinations <- tidyr::expand_grid(
all_gauges,
non_drought_streamflow_models,
all_objective_functions
) |>
unclass()
# remove a list level for the streamflow_model and objective_functions
non_drought_combinations <- unlist(non_drought_combinations, recursive = FALSE)
View(non_drought_combinations)
?flatten
# remove a list level for the streamflow_model and objective_functions
x <- list_flatten(non_drought_combinations)
View(x)
# I need to find all the combinations of all_gauges, non_drought_streamflow_models and all_objective_functions
non_drought_combinations <- tidyr::expand_grid(
all_gauges,
non_drought_streamflow_models,
all_objective_functions
) |>
unclass()
# remove a list level for the streamflow_model and objective_functions
x <- list_flatten(non_drought_combinations$non_drought_streamflow_models)
View(x)
View(non_drought_combinations)
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
View(streamflow_model)
# remove a list level for the streamflow_model and objective_functions
#x <- list_flatten(non_drought_combinations$non_drought_streamflow_models)
y <- c(streamflow_model_drought_precip_auto, streamflow_model_drought_precip_only)
View(y)
View(non_drought_combinations)
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
non_drought_combinations[[1]][[1]]
non_drought_combinations[[1]][[2]]
non_drought_combinations[[2]][[1]]
non_drought_combinations[[3]][[1]]
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
rlang::last_trace()
View(non_drought_combinations)
x <- numerical_optimiser_objects(gauge = non_drought_combinations[[1]][1],
streamflow_model = non_drought_combinations[[2]][1],
objective_function = non_drought_combinations[[3]][1],
data = data,
start_stop = start_stop_indexes)
x <- noquote(streamflow_model)
x <- streamflow_model
x <- unlist(streamflow_model)
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
x <- numerical_optimiser_objects(gauge = non_drought_combinations[[1]][[1]],
streamflow_model = non_drought_combinations[[2]][[1]],
objective_function = non_drought_combinations[[3]][[1]],
data = data,
start_stop = start_stop_indexes)
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
View(x)
View(non_drought_combinations)
y <- pmap(.l = non_drought_combinations,
.f = numerical_optimiser_objects,
data = data,
start_stop = start_stop_indexes
)
numerical_optimiser_objects <- function(gauge, streamflow_model, objective_function, data, start_stop) {
{{  gauge }} |>
catchment_data_blueprint(
observed_data = data,
start_stop_indexes = start_stop
) |>
numerical_optimiser_setup_vary_inputs(
streamflow_model = {{ streamflow_model }},
objective_function = {{ objective_function }},
bounds_and_transform_method = make_default_bounds_and_transform_methods(),
minimise_likelihood = FALSE
)
}
x <- numerical_optimiser_objects(gauge = non_drought_combinations[[1]][[1]],
streamflow_model = non_drought_combinations[[2]][[1]],
objective_function = non_drought_combinations[[3]][[1]],
data = data,
start_stop = start_stop_indexes)
y <- pmap(.l = non_drought_combinations,
.f = numerical_optimiser_objects,
data = data,
start_stop = start_stop_indexes
)
numerical_optimiser_objects <- function(gauge, streamflow_model, objective_function, data, start_stop) {
x <- gauge |>
catchment_data_blueprint(
observed_data = data,
start_stop_indexes = start_stop
) |>
numerical_optimiser_setup_vary_inputs(
streamflow_model = streamflow_model,
objective_function = objective_function,
bounds_and_transform_method = make_default_bounds_and_transform_methods(),
minimise_likelihood = FALSE
)
}
x <- numerical_optimiser_objects(gauge = non_drought_combinations[[1]][[1]],
streamflow_model = non_drought_combinations[[2]][[1]],
objective_function = non_drought_combinations[[3]][[1]],
data = data,
start_stop = start_stop_indexes)
y <- pmap(.l = non_drought_combinations,
.f = numerical_optimiser_objects,
data = data,
start_stop = start_stop_indexes
)
View(non_drought_combinations)
# I need to find all the combinations of all_gauges, non_drought_streamflow_models and all_objective_functions
non_drought_combinations <- tidyr::expand_grid(
all_gauges,
non_drought_streamflow_models,
all_objective_functions
) |>
unclass() |>
unname()
View(non_drought_combinations)
y <- pmap(.l = non_drought_combinations,
.f = numerical_optimiser_objects,
data = data,
start_stop = start_stop_indexes
)
non_drought_streamflow_models <- get_non_drought_streamflow_models()[1:2]
drought_streamflow_models <- get_drought_streamflow_models()[1:2]
all_gauges <- unique(gauge_information$gauge)[1:2]
drought_gauges <- gauge_information |>
filter(drought) |>
pull(gauge) |>
unique()
non_drought_streamflow_models <- get_non_drought_streamflow_models()[1:2]
drought_streamflow_models <- get_drought_streamflow_models()[1:2]
all_objective_functions <- get_all_objective_functions()
# I need to find all the combinations of all_gauges, non_drought_streamflow_models and all_objective_functions
non_drought_combinations <- tidyr::expand_grid(
all_gauges,
non_drought_streamflow_models,
all_objective_functions
) |>
unclass() |>
unname() # names breaks pmap? I don't know why
View(non_drought_combinations)
numerical_optimiser_objects <- function(gauge, streamflow_model, objective_function, data, start_stop) {
gauge |>
catchment_data_blueprint(
observed_data = data,
start_stop_indexes = start_stop
) |>
numerical_optimiser_setup_vary_inputs(
streamflow_model = streamflow_model,
objective_function = objective_function,
bounds_and_transform_method = make_default_bounds_and_transform_methods(),
minimise_likelihood = FALSE
)
}
x <- numerical_optimiser_objects(gauge = non_drought_combinations[[1]][[1]],
streamflow_model = non_drought_combinations[[2]][[1]],
objective_function = non_drought_combinations[[3]][[1]],
data = data,
start_stop = start_stop_indexes)
y <- pmap(.l = non_drought_combinations,
.f = numerical_optimiser_objects,
data = data,
start_stop = start_stop_indexes
)
View(y)
name_test <- function(streamflow_model) {
quote(streamflow_model)
}
name_test(streamflow_model_drought_precip_auto)
name_test <- function(streamflow_model) {
quote({{ streamflow_model }})
}
name_test(streamflow_model_drought_precip_auto)
name_test <- function(streamflow_model) {
{{ streamflow_model }}
}
name_test(streamflow_model_drought_precip_auto)
name_test <- function(streamflow_model) {
paste(streamflow_model)
}
name_test(streamflow_model_drought_precip_auto)
name_test <- function(streamflow_model) {
as.character(substitute(streamflow_model))
}
name_test(streamflow_model_drought_precip_auto)
# Put in utility
convert_object_variable_to_character <- function(variable) {
as.character(substitute(variable))
}
name_test(streamflow_model_drought_precip_auto)
## Utility functions ===========================================================
source("./Functions/utility.R")
name_test(streamflow_model_drought_precip_auto)
# Allows running in parallel with chunking to not exceed RAM
run_and_save_chunks_optimiser_parallel <- function(chunked_numerical_optimisers, chunk_id, optimiser, is_drought) {
tictoc::tic()
calibrated_results <- furrr::future_map(
.x = chunked_numerical_optimisers,
.f = optimiser,
print_monitor = FALSE,
.options = furrr_options(
globals = TRUE,
seed = TRUE
)
)
# Purrr does not work in parallel, so I don't need plan(sequential)
sort_results <- purrr::map(.x = calibrated_results, .f = result_set)
# I do not want to assign a variable name. Garbage collector works better like this.
purrr::map(.x = sort_results, .f = parameters_summary) |>
purrr::list_rbind() |>
#dplyr::slice_min( # Only take the min LL of each combination of replicates
# loglikelihood,
#by = c(gauge, streamflow_model, objective_function, optimiser)
#) |>
readr::write_csv(
file = paste0(
"./Results/",
optimiser,
"/",
if_else(is_drought, "drought_", ""),
"parameter_results_chunk_",
chunk_id,
"_",
get_date(),
".csv"
)
)
purrr::map(
.x = sort_results,
.f = modelled_streamflow_summary
) |>
purrr::list_rbind() |>
#dplyr::slice_min( # Only take the min LL of each combination of replicates
# loglikelihood,
#by = c(gauge, streamflow_model, objective_function, optimiser)
#) |>
readr::write_csv(
file = paste0(
"./Results/",
optimiser,
"/",
if_else(is_drought, "drought_", ""),
"streamflow_results_chunk_",
chunk_id,
"_",
get_date(),
".csv"
)
)
cat(paste0("Chunk ", chunk_id, " complete "))
tictoc::toc()
cat("\n")
# Remove objects for garbage collection
rm(list = c("calibrated_results", "sort_results"))
# Call garbage collection
gc()
}
# Allows running in parallel with chunking to not exceed RAM
run_and_save_chunks_optimiser_parallel <- function(chunked_numerical_optimisers, chunk_id, optimiser, is_drought) {
tictoc::tic()
calibrated_results <- furrr::future_map(
.x = chunked_numerical_optimisers,
.f = optimiser,
print_monitor = FALSE,
.options = furrr_options(
globals = TRUE,
seed = TRUE
)
)
# Purrr does not work in parallel, so I don't need plan(sequential)
sort_results <- purrr::map(.x = calibrated_results, .f = result_set)
# I do not want to assign a variable name. Garbage collector works better like this.
purrr::map(.x = sort_results, .f = parameters_summary) |>
purrr::list_rbind() |>
#dplyr::slice_min( # Only take the min LL of each combination of replicates
# loglikelihood,
#by = c(gauge, streamflow_model, objective_function, optimiser)
#) |>
readr::write_csv(
file = paste0(
"./Results/",
convert_object_variable_to_character(optimiser),
"/",
if_else(is_drought, "drought_", ""),
"parameter_results_chunk_",
chunk_id,
"_",
get_date(),
".csv"
)
)
purrr::map(
.x = sort_results,
.f = modelled_streamflow_summary
) |>
purrr::list_rbind() |>
#dplyr::slice_min( # Only take the min LL of each combination of replicates
# loglikelihood,
#by = c(gauge, streamflow_model, objective_function, optimiser)
#) |>
readr::write_csv(
file = paste0(
"./Results/",
convert_object_variable_to_character(optimiser),
"/",
if_else(is_drought, "drought_", ""),
"streamflow_results_chunk_",
chunk_id,
"_",
get_date(),
".csv"
)
)
cat(paste0("Chunk ", chunk_id, " complete "))
tictoc::toc()
cat("\n")
# Remove objects for garbage collection
rm(list = c("calibrated_results", "sort_results"))
# Call garbage collection
gc()
}
ready_for_optimisation <- pmap(.l = non_drought_combinations,
.f = numerical_optimiser_objects,
data = data,
start_stop = start_stop_indexes
)
x <- run_and_save_chunks_optimiser_parallel(
chunked_numerical_optimisers = ready_for_optimisation,
chunk_id = 1,
optimiser = my_dream,
is_drought = FALSE
)
?dream
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
debugSource("~/PHD/Papers/RQ2/climate-change-statistical-streamflow-modelling/03-dream-model-fitting.R")
# Run DREAM --------------------------------------------------------------------
tic()
gauge <- "407214"
dream_example <- gauge |>
catchment_data_blueprint(
observed_data = data,
start_stop_indexes = start_stop_indexes
) |>
numerical_optimiser_setup_vary_inputs(
streamflow_model = streamflow_model_precip_only,
objective_function = CO2_variable_objective_function,
bounds_and_transform_method = make_default_bounds_and_transform_methods(),
minimise_likelihood = FALSE
) |>
my_dream() |>
result_set()
dream_parameters <- dream_example |>
parameters_summary()
dream_example |>
plot()
toc()
test_sequences <- dream_example$sequences
View(test_sequences)
## Import streamflow functions =================================================
source("./Functions/streamflow_models.R")
source("./Functions/parameter_transformations.R")
source("./Functions/catchment_data_blueprint.R")
source("./Functions/cmaes_dream_summaries.R")
source("./Functions/objective_functions.R")
source("./Functions/numerical_optimiser_setup.R")
source("./Functions/generic_functions.R")
source("./Functions/my_dream.R")
source("./Functions/objective_function_setup.R")
source("./Functions/result_set.R")
# Run DREAM --------------------------------------------------------------------
tic()
gauge <- "407214"
dream_example <- gauge |>
catchment_data_blueprint(
observed_data = data,
start_stop_indexes = start_stop_indexes
) |>
numerical_optimiser_setup_vary_inputs(
streamflow_model = streamflow_model_precip_only,
objective_function = CO2_variable_objective_function,
bounds_and_transform_method = make_default_bounds_and_transform_methods(),
minimise_likelihood = FALSE
) |>
my_dream() |>
result_set()
View(dream_example)
test_sequences <- dream_example$sequences
View(test_sequences)
x <- sequences_summary(dream_example)
x <- sequences_summary(dream_example)
test_sequences <- dream_example$sequences
View(test_sequences)
# This will require reworking to get to the same form as the others
sequences_summary <- function(x) {
x$sequences |>
pivot_longer(
cols = everything(),
names_to = "parameter",
values_to = "parameter_values"
)
}
x <- sequences_summary(dream_example)
View(x)
# This will require reworking to get to the same form as the others
sequences_summary <- function(x) {
tibble::as_tibble(
list(
"gauge" = x$numerical_optimiser_setup$catchment_data$gauge_ID,
"streamflow_model" = x$numerical_optimiser_setup$streamflow_model()$name,
"objective_function" = x$numerical_optimiser_setup$objective_function()$name,
"optimiser" = sloop::s3_class(x$optimised_object)[1]
)
)
#x$sequences |>
#  pivot_longer(
#    cols = everything(),
#    names_to = "parameter",
#    values_to = "parameter_values"
#  )
}
x <- sequences_summary(dream_example)
View(x)
# This will require reworking to get to the same form as the others
sequences_summary <- function(x) {
tibble::as_tibble(
list(
"gauge" = x$numerical_optimiser_setup$catchment_data$gauge_ID,
"streamflow_model" = x$numerical_optimiser_setup$streamflow_model()$name,
"objective_function" = x$numerical_optimiser_setup$objective_function()$name,
"optimiser" = sloop::s3_class(x$optimised_object)[1],
"test" = c(x$sequences)
)
)
#x$sequences |>
#  pivot_longer(
#    cols = everything(),
#    names_to = "parameter",
#    values_to = "parameter_values"
#  )
}
x <- sequences_summary(dream_example)
View(x)
# Fitting streamflow models to catchments
cat("\014") # clear console
# Import libraries--------------------------------------------------------------
pacman::p_load(tidyverse, cmaesr, smoof, tictoc, furrr, parallel, truncnorm, sloop, tictoc)
## Import annual streamflow, precip, CO2 and gauge data ========================
start_stop_indexes <- readr::read_csv(
"./Data/Tidy/start_end_index.csv",
show_col_types = FALSE
)
data <- readr::read_csv(
"./Data/Tidy/with_NA_yearly_data_CAMELS.csv",
col_types = "icdddddddll", # ensuring each column is a the correct type
show_col_types = FALSE
)
gauge_information <- readr::read_csv(
"./Data/Tidy/gauge_information_CAMELS.csv",
show_col_types = FALSE
)
## Utility functions ===========================================================
source("./Functions/utility.R")
View(data)
x <- data |>
pull(q_mm)
x <- data |>
filter(q_mm < 1)
View(x)
prob_boxcox_observed <- truncnorm::dtruncnorm(
x = 5,
a = 0,
b = Inf,
mean = -1,
sd = 2
)
